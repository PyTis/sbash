#!/usr/bin/env python
# -*- coding:yram utf-8 -*-
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version		#
# 3.0 (the "License"); you may not use this file except in compliance with		 #
# the License. You may obtain a copy of the License at												 #
#																																							#
#		 http://www.PyTis.com/License/																						#
#																																							#
#		 Copyright (c) 2019 Josh Lee																							#
#																																							#
# Software distributed under the License is distributed on an "AS IS" basis,	 #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License		 #
# for the specific language governing rights and limitations under the				 #
# License.																																		 #
#																																							#
# @auto-generated by the PyTis Copyright Tool on 10:46 PM - 07 Jan, 2019			 #
############################################################################## #
"""pylock
======

NAME:
	pylock

SYNOPSIS:
	pylock [--options] [-H] [-V] [-D]

DESCRIPTION:

CODE:



UNDERSTANDING LOGGING and OUTPUT:

 The way my PyTis scripts and programs work, I hardly ever use the print
 command.	Instead I just log something using a custom logging class.	I have
 four log levels: debug, info, warn and error. Messages may or may not make it
 to the screen (as my logging class will print output as it logs) depending on
 which arguments you pass into the program you are executing.

 The current setup allows for 2 log files, to be written to the PyTis
 configured log directory.	If you do not use debug, then the log file used
 will be the pytis_tools.log, if debugging is turned on, then the log file will
 be {program_name}.log found in the same directory.	In this program's case
 that would be pybkup.log	So if you use -D the output ends up in a different
 log file, but this is just to keep debugging separate from normal logging.	-V
 --verbose is off by default by with this program, unless you use the action
 'test' then it is on (unless you specify --quiet, then it stays off).


 debug:
	Not to log-file or to screen by default, but if turned on with the -D or
		--debug flag, it will always end up in the debug log file (pybkup.log).

	-D: print debug messages to log only

	-V: alone does not print debug messages anywhere, because -D or --debug not
		given

	-DV: now debug messages are sent to their log file, and make it to the screen

 info:
	Print normal level information, always written to log (although which log is
		being used depends on if you are using debugging, as stated above).

	-V allows info messages to print to STDOUT, thus to the screen for you to
		see.

	-q or --quiet turns off -V


 warn:
	Warnings will always make it to which ever log is being used, and it will
		always make it to the screen unless -q is passed in.	If -q is passed in
		then warnings are hidden from STDOUT, thus only show in log files.

	-q suppresses warnings to STDOUT (the screen) but they will still end up in
		whichever log this program is using.

 error:
	error messages always make it to the screen, no matter what; and are always
		logged to the log file as well.

 Notes:
	To ensure there is no confusion, I want to specify that the log file is
		chosen one time during the first stages of the program firing up, it does
		not switch back and forth while running, nothing complex like that.	Simply
		this, all of my programs share pytis_tools.log unless they are in debug
		mode.	Then, since they are obviously going to spit out allot more
		information, they write to their very own log file for that run.	That way
		they don't fill up and clutter the shared pytis_tools.log

	'-DVq' confuses my little logging class.	-q silences most messages, nothing
		but errors make it to the screen, -D was passed in so the debug log is used
		(pybkup.log) however logging level is set to verbose, with nothing to the
		screen so what ends up happening is only info messages make it to the debug
		log (debug messages hidden).

DEPENDENCIES:

"""

# ############################ DO NOT EDIT BELOW ############################ #
errors = []

# =============================================================================
# Begin Imports
# -----------------------------------------------------------------------------
# builtin
import optparse
import shlex
import time
import atexit
import os
import logging
import sys
import threading
from subprocess import PIPE
import subprocess as sp
import platform
from pprint import pprint
from cStringIO import StringIO

import idle.idle as Idle

# =============================================================================
# End Imports
# -----------------------------------------------------------------------------


__author__ = 'Josh Lee'
__copyright__ = 'PyTis.com'
__created__ = '08:32pm 04 Mar, 2018'
__curdir__ = os.path.abspath(os.path.dirname(__file__))
__version__ = '0.1'


# =============================================================================
# Begin HELPER Functions
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# End HELPER Functions
# =============================================================================

def main():
	"""usage: pylock [-a/--action] [-Dv] (example: pylock)
	"""
	global __configdir__, errors, log

	PyTis.__option_always__ = [True]
	help_dict = dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	parser = PyTis.MyParser()

	parser.extra_txt = "\n\n%s\n" % run.__doc__ + """

EXAMPLES:	
	pylock

SEE ALSO:
	vlock
	/local/bin/lck or /usr/bin/lock 

COPYRIGHT:
	%(copyright)s

AUTHOR:
	%(author)s

CHANGE LOG:

	v0.1 MINOR CHANGE
		Ran importnanny and removed un-needed imports.

CREATED:
	%(created)s

HISTORY:
	Original Author

TODO:
	Screen Savers...  Completing this will bring pylock to 100%%, and
	thus, version 1.

VERSION:
	%(version)s
""" % help_dict

	parser.formatter.format_description = lambda s:s
	if '--help' in sys.argv:
		parser.set_description(__doc__)
		helpishere=True # to determine help mode (short or full)
		# "Only tell the user    "
		dry_run_help = 'Enable the dry-run flag (-d/--dry-run) in order to test ' \
			'what this script would do, if ran normally.  Dry Run does not ' \
			' re-cache, send emails, run commands, or run sql statements (see ' \
			'"Configuring Actions" section of full help text), and thus in ' \
			'repitition would continue to report that a file has changed.  ' \
			'If the file has changed since the previous non-dry-run caching of ' \
			'said URL, output will reflect such.  If a URL has not changed since ' \
			'the last cached URL, then the output will state there is no change. ' \
			'Dry Run [-d/--dry-run] is great for when an adminstrator (or user) ' \
			'wishes to just test and see if anything has changed, without any ' \
			'actions taking place.  Generally the actions are fired off when ' \
			'this program is callef rom the cron jobs.`$' \
			'Lastly, using the [-d/--dry-run] flag, implies verbosity, and unless ' \
			'the [-q/--quiet] flag is provided, this program will default to ' \
			'verbose mode.`$'
	else:

		parser.set_description('')
		helpishere=False # to determine help mode (short or full)
		dry_run_help = 'Reports changes as STDOUT, without executing any '\
			'configured actions, or caching.  Implies "verbosity."' \
			' *(use "--help" for more details)`$'

	runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")

	runtime.add_option("-d", "--dry-run", action="store_true", #type="bool",
		default=False, dest='dry_run',
		help=dry_run_help)
		#help=optparse.SUPPRESS_HELP)

	parser.add_option_group(runtime)
	# -------------------------------------------------------------------------
	# variable setting
	vars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")

	parser.add_option_group(vars)
	# ----------------------------
	dbgroup = optparse.OptionGroup(parser, "-- DEBUG")
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging`$")


	# This is a little trick to tell if the user entered the -V/--verbose flag.
	# We want verbosity on by default, but we also want to know if the user
	# entered it for debug items, and providing end messages vs informed output.
	dbgroup.add_option("", "--totaly-verbose", action="store_true",
		default=False, dest='totally_verbose', 
		help=optparse.SUPPRESS_HELP)

	dbgroup.add_option("-V", "--verbose", action="store_true",
					 default=False, dest='verbose',
					 help="Be more Verbose (make lots of noise).  Off by default, " \
					 "unless in dry-run.`$")

	dbgroup.add_option("-q", "--quiet", action="store_true",
					 default=False, dest='quiet',
					 help="be vewwy quiet (I'm hunting wabbits).  On by default, " \
					 "unless in dry-run.`$")

	dbgroup.add_option("-v", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version")

	parser.add_option_group(dbgroup)
	# ----------------------------

	(opts, args) = parser.parse_args()
	if opts.verbose: 
		opts.totally_verbose = True
	if opts.quiet: opts.verbose = False

	if opts.dry_run and not opts.quiet: opts.verbose = True

	#if not opts.quiet: opts.verbose = True # Defaults to Verbose
	if not opts.verbose: opts.quiet = True # Defaults to Quiet 


	if opts.debug:
		main.__doc__ = "%s\n\n	CONFIG FILE: %s" % (main.__doc__, \
			os.path.abspath(config_filename))
	else:
		pass

	parser.set_usage(main.__doc__)

	old_version = opts.version
	opts.version = True
	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))
	opts.version = old_version

	if opts.version:
		return PyTis.version(__version__)

	if not opts.quiet and not opts.verbose and len(args)==0 and not errors:
		return parser.print_usage()
	elif not errors:
		try:
			run(opts, config)
		except KeyboardInterrupt,e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return 0
		else:
			if opts.totally_verbose: log.info("Done.")
			return 0
	else:
		parser.print_usage()
		if errors:
			log.error(str("\n".join(errors)))
		return parser.print_help(errors)

	parser.print_help("ERROR: Unknown, but invalid input.")
	sys.exit(1)


if __name__ == '__main__':
		sys.exit(main())


