#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version		#
# 3.0 (the "License"); you may not use this file except in compliance with		 #
# the License. You may obtain a copy of the License at												 #
#																																							#
#		 http://www.PyTis.com/License/																						#
#																																							#
#		 Copyright (c) 2019 Josh Lee																							#
#																																							#
# Software distributed under the License is distributed on an "AS IS" basis,	 #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License		 #
# for the specific language governing rights and limitations under the				 #
# License.																																		 #
#																																							#
# @auto-generated by the PyTis Copyright Tool on 10:46 PM - 07 Jan, 2019			 #
############################################################################## #
"""pylock
======

NAME:
	pylock

SYNOPSIS:
	pylock [--options] [-H] [-v] [-D]

DESCRIPTION:

CODE:



UNDERSTANDING LOGGING and OUTPUT:

 The way my PyTis scripts and programs work, I hardly ever use the print
 command.	Instead I just log something using a custom logging class.	I have
 four log levels: debug, info, warn and error. Messages may or may not make it
 to the screen (as my logging class will print output as it logs) depending on
 which arguments you pass into the program you are executing.

 The current setup allows for 2 log files, to be written to the PyTis
 configured log directory.	If you do not use debug, then the log file used
 will be the pytis_tools.log, if debugging is turned on, then the log file will
 be {program_name}.log found in the same directory.	In this program's case
 that would be pybkup.log	So if you use -D the output ends up in a different
 log file, but this is just to keep debugging separate from normal logging.	v-
 --verbose is off by default by with this program, unless you use the action
 'test' then it is on (unless you specify --quiet, then it stays off).


 debug:
	Not to log-file or to screen by default, but if turned on with the -D or
		--debug flag, it will always end up in the debug log file (pybkup.log).

	-D: print debug messages to log only

	-v: alone does not print debug messages anywhere, because -D or --debug not
		given

	-DV: now debug messages are sent to their log file, and make it to the screen

 info:
	Print normal level information, always written to log (although which log is
		being used depends on if you are using debugging, as stated above).

	-v allows info messages to print to STDOUT, thus to the screen for you to
		see.

	-q or --quiet turns off -v


 warn:
	Warnings will always make it to which ever log is being used, and it will
		always make it to the screen unless -q is passed in.	If -q is passed in
		then warnings are hidden from STDOUT, thus only show in log files.

	-q suppresses warnings to STDOUT (the screen) but they will still end up in
		whichever log this program is using.

 error:
	error messages always make it to the screen, no matter what; and are always
		logged to the log file as well.

 Notes:
	To ensure there is no confusion, I want to specify that the log file is
		chosen one time during the first stages of the program firing up, it does
		not switch back and forth while running, nothing complex like that.	Simply
		this, all of my programs share pytis_tools.log unless they are in debug
		mode.	Then, since they are obviously going to spit out allot more
		information, they write to their very own log file for that run.	That way
		they don't fill up and clutter the shared pytis_tools.log

	'-DVq' confuses my little logging class.	-q silences most messages, nothing
		but errors make it to the screen, -D was passed in so the debug log is used
		(pybkup.log) however logging level is set to verbose, with nothing to the
		screen so what ends up happening is only info messages make it to the debug
		log (debug messages hidden).

DEPENDENCIES:

"""

# ############################ DO NOT EDIT BELOW ############################ #
errors = []

# =============================================================================
# Begin Imports
# -----------------------------------------------------------------------------
# builtin
import optparse
import shlex
import time
import atexit
import os
import logging
import sys
import threading
from subprocess import PIPE
import subprocess as sp
import platform
from pprint import pprint
from cStringIO import StringIO

import idle.idle as Idle

# This program needs to import PyTis(2) v4.1, which imports modules from the
# sub-package pylib, this program also needs to import from the sub-package
# cobj, pylib.cobj itself, has to import from the parent, pytis, which it
# can only do if the parent directory is a package, turning the parent (bin)
# into a package breaks importing pytis for this program in the first place
# and caused severe circular import errors.	To fix this, we have to adjust the
# path.
# vvvvv XXX-TODO may not need this here, dunno, remove at end and try it. vvvvv
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__),'..')))
# ^^^^^ XXX-TODO may not need this here, dunno, remove at end and try it. ^^^^^

#
# Internal
#
try:
	#from pers import	PyTis # Shared GPL/PPL License
	import pytis as PyTis # Shared GPL/PPL License
	from pylib import configobj as COBJ
except ImportError as e:
	# We cannot go any further than this, we can't use the Parser or Logging tool
	# to display these errors because those very tools are loaded from PyTis.
	# Therefore, display errors now and exit with an errored exit code.
	print("This program requires the PyTis Python library to run.")
	print("You may download the PyTis library, or do an SVN checkout from:")
	print("<https://sourceforge.net/projects/pytis/>")
	print("This program should be installed in the bin directory of the PyTis library.")
	print(str(e))
	sys.exit(1)

is_debian = 'debian' in ' '.join(platform.dist()).lower() or 'ubuntu' in \
	' '.join(platform.dist()).lower()

#
# Third-Party
#

# =============================================================================
# End Imports
# -----------------------------------------------------------------------------


__author__ = 'Josh Lee'
__copyright__ = 'PyTis.com'
__created__ = '08:32pm 04 Mar, 2018'
__curdir__ = os.path.abspath(os.path.dirname(__file__))
__version__ = '0.1'


# =============================================================================
# Begin HELPER Functions
# -----------------------------------------------------------------------------

class LockScreen (object):
	pass

class LockScreenThread(PyTis.MyThread):


	def __init__(self):
		''' So, "Start" could be Confused with Run, but "Start" fires the process
		up, and gets the wheels turning, then will actually call "Run".  Once
		"Start" is called, it next calls lowercase "start" to do anything that
		should happen when the program is started.  Then, it calls "Run" which is
		the threaded function, that may be called multiple times.
		"_run" is only called, when the programmer forgets to assign any callbacks. 
		Remmember, "Run" is the thread.  It can call "_stop", if it needs to exit.	
		"_stop" calls "stop" which can be overridden, it's purpose is last minute
		cleanup, for example, a user presses CTRL+c, for a KeyboardInterrupt, log
		files need closing, etc.
		"Stop" is called by this program, but another instance, that can look up a
		deamon finding it's PID, and sending a SIGTERM.

		'''

		global log
		threading.Thread.__init__(self, target=self.Run, name='LockScreen-Thread')

		self.keep_going=True
		if log is not None:
			self.setLogFile(log)
		atexit.register(self.stop)

	def _run(self):
		self.log.warn('running placeholder until callbacks are set')
		#PyTis.clearScreen()
		#self.log.info("Hello")


	def _stop(self):
		self.keep_going=False
		self.stop()

	def start(self):
		''' You should override this method when you subclass Process.
It will be called before the process will be runned via when you call caplital 
Start. '''
		#self.log.debug('override start')
		pass

	def stop(self):
		''' CALLED atexit REGISTERED in INIT, also called by _stop, which is called
		in Run, when keep_going is found to be False.
		'''
		"""
		You should override this method when you subclass Process.
It will be called after the process has been stopped or interupted by
signal.SIGTERM"""
		#self.log.debug('override stop')
		pass

	def Start(self):
		stderr = sys.stderr
		old_pid = self.pidfile.validate()
		if old_pid:
			self.log.error("Error during service start:\n " \
				"Already running on PID %s (or pid file '%s' is stale)" % \
				(old_pid, self.pidfile.pidfile))
			return

		# Start the service
		self.log.info("starting the %s service now" % (self.parent_name))
		if self.daemonize():
			try:
				self.pidfile.create()
			except RuntimeError as err:
				# *IMPORTANT* No matter what, this will not make it to the screen.
				# Even print statements won't make it to the screen from here.
				# This is already within the spawned child process with no open pipes
				# to the parent.	The best we can do is log.
				self.log.error("Error during service start: %s" % str(err))
				return

			atexit.register(self.remove_pid)
			self.start()
			try:
				self.keep_going = True
				self.running = True
#				thread.start_new_thread(self.Run, None, self.opts)
				t=threading.Thread(None,self.Run,None)
#				self.Run()
				t.start()
				#t.opts=self.opts
			#	t.join()
			except Exception as e:
				self.keep_going=False
				self.running=False
				self.log.error(e)
				#print >> sys.stderr, e
				#sys.stderr.write(str(e))
				raise Exception(e)
				return
			self.log.info('%s service started' % self.parent_name)
		else:
			self.log.info("Success, all done")
		return

	def Stop(self):
		pid = self.pidfile.validate()
		if not pid:
			self.log.error("pidfile %s does not exist. The %s service is not " \
			"running." % (self.pidfile.pidfile, self.parent_name))
			return # not an error in a restart

		# Try killing the service process
		try:
			while 1:
				os.kill(pid, signal.SIGTERM)
				time.sleep(0.1)
		except OSError as err:
			err = str(err)
			if err.find("No such process") > 0:
				self.pidfile.unlink()
			else:
				self.log.error('Error during service stop, %s' % str(err))
				raise OSError(err)

		self.log.info('stopping %s [%s] service.' %(self.parent_name, pid))
		self.log.debug('service [%s] was stopped by SIGTERM signal' % pid)

	#def remove_pid(self):
	#	if self.pidfile.validate(): self.pidfile.unlink()


	def Run(self):
		print("called by thread")
		return 0
		i=0
		os.nice(self.niceness)
		while self.keep_going:
			if not self.callbacks:
				self._run()
			else:	
				if self.frequency or ( not self.frequency and not i):
					for v in self.callbacks:
						callback = v.getCallback()
						args = v.getArgs()
						kwargs = v.getKwArgs()
						try:
							callback(*args,**kwargs)
						except (KeyboardInterrupt, QuitNow) as e:
							print("\nbye!")
							self.keep_going = False
							self._stop()
							self.running=False
							return
						except Exception as e:
							self.log.error("Some error occured.")
							type_,value_,traceback_ = sys.exc_info()
							self.log.debug("type: %s" % type_)
							self.log.debug("type2: %s" %type(e))
							self.log.debug("value: %s" % value_)
							for tb_line in traceback.format_tb(traceback_):
								self.log.debug(tb_line)
							self.log.error(str(e))

				if not self.frequency and not i:
						self._stop()
						self.running=False
						return

			if self.frequency:
				time.sleep(self.frequency)
				
			try:
				if self.opts.debug:
					i+=1
					if i > 2: 
						self._stop()
						self.running=False
						return
			except (AttributeError, NameError) as e:
				pass



def run(opts, config):
	""" Okay, I know I can just keep this in a function, K.I.S.S., and I hope I
	am not horribly breaking the KISS rule, but I am usually going to be calling
	this with the need for it to be in a thread.  Therefore, I am going to write
	it into a class to make it easier in the future for threading. 

	"""
	lock_screen = LockScreen()
	lock_screen2 = LockScreenThread()
	lock_screen2.opts = opts
	lock_screen2.start()


# -----------------------------------------------------------------------------
# End HELPER Functions
# =============================================================================

def main():
	"""usage: pylock [--PAM] [-Dv] (example: pylock)
	"""
	global __configdir__, errors, log

	PyTis.__option_always__ = [True]
	help_dict = dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	parser = PyTis.MyParser()

	parser.extra_txt = "\n\n%s\n" % run.__doc__ + """

EXAMPLES:	
	pylock

SEE ALSO:
	vlock
	/local/bin/lck or /usr/bin/lock 

COPYRIGHT:
	%(copyright)s

AUTHOR:
	%(author)s

CHANGE LOG:

	v.1 MINOR CHANGE
		Ran importnanny and removed un-needed imports.

CREATED:
	%(created)s

HISTORY:
	Original Author

TODO:
	Screen Savers...  Completing this will bring pylock to 100%%, and
	thus, version 1.

VERSION:
	%(version)s
""" % help_dict

	parser.formatter.format_description = lambda s:s
	if '--help' in sys.argv:
		parser.set_description(__doc__)
		helpishere=True # to determine help mode (short or full)
		# "Only tell the user    "
		dry_run_help = 'Enable the dry-run flag (-d/--dry-run) in order to test ' \
			'what this script would do, if ran normally.  Dry Run does not ' \
			' re-cache, send emails, run commands, or run sql statements (see ' \
			'"Configuring Actions" section of full help text), and thus in ' \
			'repitition would continue to report that a file has changed.  ' \
			'If the file has changed since the previous non-dry-run caching of ' \
			'said URL, output will reflect such.  If a URL has not changed since ' \
			'the last cached URL, then the output will state there is no change. ' \
			'Dry Run [-d/--dry-run] is great for when an adminstrator (or user) ' \
			'wishes to just test and see if anything has changed, without any ' \
			'actions taking place.  Generally the actions are fired off when ' \
			'this program is callef rom the cron jobs.`$' \
			'Lastly, using the [-d/--dry-run] flag, implies verbosity, and unless ' \
			'the [-q/--quiet] flag is provided, this program will default to ' \
			'verbose mode.`$'
	else:

		parser.set_description('')
		helpishere=False # to determine help mode (short or full)
		dry_run_help = 'Reports changes as STDOUT, without executing any '\
			'configured actions, or caching.  Implies "verbosity."' \
			' *(use "--help" for more details)`$'

	runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")

	runtime.add_option("-d", "--dry-run", action="store_true", #type="bool",
		default=False, dest='dry_run',
		help=dry_run_help)
		#help=optparse.SUPPRESS_HELP)

	parser.add_option_group(runtime)
	# -------------------------------------------------------------------------
	# variable setting
	vars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")

	parser.add_option_group(vars)
	# ----------------------------
	dbgroup = optparse.OptionGroup(parser, "-- DEBUG")
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging`$")


	# This is a little trick to tell if the user entered the -v/--verbose flag.
	# We want verbosity on by default, but we also want to know if the user
	# entered it for debug items, and providing end messages vs informed output.
	dbgroup.add_option("", "--totaly-verbose", action="store_true",
		default=False, dest='totally_verbose', 
		help=optparse.SUPPRESS_HELP)

	dbgroup.add_option("-v", "--verbose", action="store_true",
					 default=False, dest='verbose',
					 help="Be more Verbose (make lots of noise).  Off by default, " \
					 "unless in dry-run.`$")

	dbgroup.add_option("-q", "--quiet", action="store_true",
					 default=False, dest='quiet',
					 help="be vewwy quiet (I'm hunting wabbits).  On by default, " \
					 "unless in dry-run.`$")

	dbgroup.add_option("-V", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version")

	parser.add_option_group(dbgroup)
	# ----------------------------

	(opts, args) = parser.parse_args()
	if opts.verbose: 
		opts.totally_verbose = True
	if opts.quiet: opts.verbose = False

	if opts.dry_run and not opts.quiet: opts.verbose = True

	if not opts.quiet: opts.verbose = True # Defaults to Verbose
	#if not opts.verbose: opts.quiet = True # Defaults to Quiet 


	if opts.debug:
		main.__doc__ = "%s\n\n	CONFIG FILE: %s" % (main.__doc__, \
			os.path.abspath('none.txt'))
	else:
		pass

	parser.set_usage(main.__doc__)

	old_version = opts.version
	opts.version = True
	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))
	opts.version = old_version

	if opts.version:
		return PyTis.version(__version__)

	config={}
	if not opts.quiet and len(args) and not errors:
		return parser.print_usage()
	elif not errors:
		try:
			run(opts, config)
		except KeyboardInterrupt,e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return 0
		else:
			if opts.totally_verbose: log.info("Done.")
			return 0
	else:
		parser.print_usage()
		if errors:
			log.error(str("\n".join(errors)))
		return parser.print_help(errors)

	parser.print_help("ERROR: Unknown, but invalid input.")
	sys.exit(1)


if __name__ == '__main__':
		sys.exit(main())

