#!/usr/bin/env python
# -*- coding:yram utf-8 -*-
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version		#
# 3.0 (the "License"); you may not use this file except in compliance with		 #
# the License. You may obtain a copy of the License at												 #
#																																							#
#		 http://www.PyTis.com/License/																						#
#																																							#
#		 Copyright (c) 2019 Josh Lee																							#
#																																							#
# Software distributed under the License is distributed on an "AS IS" basis,	 #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License		 #
# for the specific language governing rights and limitations under the				 #
# License.																																		 #
#																																							#
# @auto-generated by the PyTis Copyright Tool on 10:46 PM - 07 Jan, 2019			 #
############################################################################## #
"""sbash
====

NAME:
	sbash

SYNOPSIS:
	sbash [--options] [-H] [-V] [-D]

DESCRIPTION:

CODE:



UNDERSTANDING LOGGING and OUTPUT:

 The way my PyTis scripts and programs work, I hardly ever use the print
 command.	Instead I just log something using a custom logging class.	I have
 four log levels: debug, info, warn and error. Messages may or may not make it
 to the screen (as my logging class will print output as it logs) depending on
 which arguments you pass into the program you are executing.

 The current setup allows for 2 log files, to be written to the PyTis
 configured log directory.	If you do not use debug, then the log file used
 will be the pytis_tools.log, if debugging is turned on, then the log file will
 be {program_name}.log found in the same directory.	In this program's case
 that would be pybkup.log	So if you use -D the output ends up in a different
 log file, but this is just to keep debugging separate from normal logging.	-V
 --verbose is off by default by with this program, unless you use the action
 'test' then it is on (unless you specify --quiet, then it stays off).


 debug:
	Not to log-file or to screen by default, but if turned on with the -D or
		--debug flag, it will always end up in the debug log file (pybkup.log).

	-D: print debug messages to log only

	-V: alone does not print debug messages anywhere, because -D or --debug not
		given

	-DV: now debug messages are sent to their log file, and make it to the screen

 info:
	Print normal level information, always written to log (although which log is
		being used depends on if you are using debugging, as stated above).

	-V allows info messages to print to STDOUT, thus to the screen for you to
		see.

	-q or --quiet turns off -V


 warn:
	Warnings will always make it to which ever log is being used, and it will
		always make it to the screen unless -q is passed in.	If -q is passed in
		then warnings are hidden from STDOUT, thus only show in log files.

	-q suppresses warnings to STDOUT (the screen) but they will still end up in
		whichever log this program is using.

 error:
	error messages always make it to the screen, no matter what; and are always
		logged to the log file as well.

 Notes:
	To ensure there is no confusion, I want to specify that the log file is
		chosen one time during the first stages of the program firing up, it does
		not switch back and forth while running, nothing complex like that.	Simply
		this, all of my programs share pytis_tools.log unless they are in debug
		mode.	Then, since they are obviously going to spit out allot more
		information, they write to their very own log file for that run.	That way
		they don't fill up and clutter the shared pytis_tools.log

	'-DVq' confuses my little logging class.	-q silences most messages, nothing
		but errors make it to the screen, -D was passed in so the debug log is used
		(pybkup.log) however logging level is set to verbose, with nothing to the
		screen so what ends up happening is only info messages make it to the debug
		log (debug messages hidden).

DEPENDENCIES:

"""

# ############################ DO NOT EDIT BELOW ############################ #
errors = []

# =============================================================================
# Begin Imports
# -----------------------------------------------------------------------------
# builtin
import optparse
import shlex
import time
import atexit
import os
import logging
import sys
import threading
from subprocess import PIPE
import subprocess as sp
import platform
from pprint import pprint
from cStringIO import StringIO

import idle.idle as Idle

# =============================================================================
# End Imports
# -----------------------------------------------------------------------------


__author__ = 'Josh Lee'
__copyright__ = 'PyTis.com'
__created__ = '08:32pm 04 Mar, 2018'
__curdir__ = os.path.abspath(os.path.dirname(__file__))
__version__ = '0.1'


# =============================================================================
# Begin HELPER Functions
# -----------------------------------------------------------------------------



def run_cmd(cmd, timeout_sec):
	shelex_split = shlex.split(cmd)
	print("shelex_split: %s" % repr(shelex_split))
	proc = sp.Popen(shelex_split)
	#proc = sp.Popen(shlex.split(cmd), stdout=PIPE, stderr=PIPE)

	#iN, out, err = os.popen3('curl ipinfo.io/ip')
	#iN.close() ; err.close()
	#ip = out.read().strip()

	timer = threading.Timer(timeout_sec, proc.kill)
	try:
		timer.start()
		stdout, stderr = proc.communicate()
	finally:
		timer.cancel()
	return stdout


# -----------------------------------------------------------------------------
# End Helpers
# =============================================================================

def run_bash():
	""" for now, I am just going to try to run cmatrix
	"""
	cmd = 'cmatrix'
	timeout_sec = 10
	print('I could run bash here. - START')
	run_cmd(cmd, timeout_sec)
	print('I could run bash here. - END')
	return 0

class AThread(threading.Thread):
	filename = None

	def run(self):
		return self.a_write(self.filename)

	def a_write(self, filename):
		global log, pulse
		log.debug("a_write called")
		return write(filename, pulse)

class BThread(threading.Thread):
	filename = None

	def run(self):
		return self.b_write(self.filename)

	def b_write(self, filename):
		global log, pulse
		log.debug("b_write called")
		return write(filename, pulse)

class CThread(threading.Thread):
	filename = None

	def run(self):
		return self.c_write(self.filename)

	def c_write(self, filename):
		global log, pulse
		log.debug("c_write called")
		return write(filename, pulse)

def write(filename, pulse):
	global log
	log.debug('write called')
	handle = open(filename, 'w')
	handle.write("%s\n" % pulse[0])
	handle.close()
	return 0
	
def run_ss():
	print('I could run a screen saver.')

pulse_int = 1
pulse = [pulse_int]

def main():
	"""usage: pers [-a/--action] [-Dv] (example: pers start)
	"""
	global errors, log, pulse

	logging.basicConfig(
		name='sbash',
		filename = 'sbash.log',
		level=logging.DEBUG,
		format='%(created)f %(asctime)s %(name)-10s %(levelname)-8s %(message)s',
		datefmt="%m.%d.%Y %H:%M:%S")
	log = logging.getLogger('sbash')

	log.info('threads collected, ready to start')

	threshold = 60*60
	while True:
		
		pulse[0] +=1
		log.info("idle: %s" % Idle.idle())
		log.info("is idle: %s" % Idle.is_idle(threshold))

		if pulse[0] > 20:
			log.info('breaking after 20')
			break

		log.info('about to sleep')
		time.sleep(1)

	print("Done.")
	return 0
	cmd = '/usr/bin/cmatrix'
	return run_cmd(cmd, 5)		

	return run_cmd('bash', 5)		
	return run_cmd('cmatrix', 5)		
	cmd = '/home/jlee/cmatrix'
	#proc = Popen(shlex.split(cmd), stdout=PIPE, stderr=PIPE)
	#proc = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)
	#stdout, stderr = proc.communicate()
	child_stdin, child_stdout, child_stderr = os.popen3('cmatrix', 'rw') 


	return
	def closethis(proc):
		def this_thing():
			if proc.isAlive():
				print('proc found still aliver, attempting to kill')
				return proc.kill()
		return this_thing


	print("attempting to close soon....")
	proc.terminate()
	print ("attempted to terminate.")
	timer = threading.Timer(2, closethis(proc))
	timer.start()
	time.sleep(3)
	print ("should be good now")
	return

	bash_thread = threading.Thread(target=run_bash, name='PyTis-Bash-Thread')
	bash_thread.start()
#bash_thread.run()
	print('did I run bash?')
	ss_thread = threading.Thread(target=run_bash,
		name='PyTis-ScreenSaver-Thread')

	print('at end now')

		#atexit.register(self.stop)
	return 0

if __name__ == '__main__':
	main()
		


